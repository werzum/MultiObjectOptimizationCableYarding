Timer unit: 1e-09 s

Total time: 6.78011 s
File: /home/carlo/GitHub/MultiObjectOptimizationCableYarding/geometry_operations.py
Function: generate_possible_lines at line 19

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    19                                           def generate_possible_lines(road_points, target_trees, anchor_trees, overall_trees, slope_line, height_gdf, plot_possible_lines):
    20                                               """Compute which lines can be made from road_points to anchor_trees without having an angle greater than max_main_line_slope_deviation
    21                                               First, we generate all possible lines between  each point along the road and all head anchors.
    22                                               For those which do not deviate more than max_main_line_slope_deviation degrees from the slope line, we compute head anchor support trees along the lines.
    23                                               If those are present, we compute triples of tail anchor support trees.
    24                                               If those are present, valid configurations are appended to the respective lists.
    25                                           
    26                                           
    27                                               Args:
    28                                                   road_points (_type_): _description_
    29                                                   target_trees (_type_): _description_
    30                                                   anchor_trees (_type_): _description_
    31                                                   slope_line (_type_): _description_
    32                                                   max_main_line_slope_deviation (_type_): How much the central of three lines can deviate from the slope
    33                                                   max_anchor_distance (_type_): How far away should the anchors be at most
    34                                           
    35                                               Returns:
    36                                                   _type_: _description_
    37                                               """    
    38         1        479.0    479.0      0.0      max_main_line_slope_deviation = 45
    39                                           
    40         1        208.0    208.0      0.0      if plot_possible_lines:
    41                                                   # Make a canvas and add simple view
    42                                                   canvas = vispy.scene.SceneCanvas(keys='interactive', show=True)
    43                                                   view = canvas.central_widget.add_view()
    44                                               else:
    45         1        120.0    120.0      0.0          view = None
    46                                               
    47                                               # generate the list of line candidates within max_slope_angle
    48         1     156275.0 156275.0      0.0      line_candidate_list = list(itertools.product(road_points, target_trees.geometry))
    49         1   25092222.0 25092222.0      0.4      line_candidate_list_combinations = [LineString(combination) for combination in line_candidate_list]
    50         1   12669367.0 12669367.0      0.2      line_df = pd.DataFrame(data={"line_candidates":line_candidate_list_combinations})
    51         1      58280.0  58280.0      0.0      print(len(line_df)," candidates initially")
    52                                           
    53                                               # filter by max_main_line_slope_deviation
    54         1   38488017.0 38488017.0      0.6      line_df["slope_deviation"] = [geometry_utilities.angle_between(line, slope_line) for line in line_candidate_list_combinations]
    55         1     485261.0 485261.0      0.0      line_df = line_df[line_df["slope_deviation"]<max_main_line_slope_deviation]
    56         1      33825.0  33825.0      0.0      print(len(line_df)," after slope deviations")
    57                                           
    58         1      41784.0  41784.0      0.0      line_df = line_df.iloc[1:250]
    59                                           
    60                                               # filter the candidates for support trees
    61                                               # overall_trees, target, point, possible_line
    62         1 3925304465.0 3925304465.0     57.9      line_df["possible_support_trees"] = [generate_support_trees(overall_trees,Point(line.coords[1]), Point(line.coords[0]), line) for line in line_df["line_candidates"]]
    63                                               # add to df and filter empty entries
    64         1     978173.0 978173.0      0.0      line_df = line_df[line_df["possible_support_trees"].apply(len)>0]
    65         1      54523.0  54523.0      0.0      print(len(line_df)," after supports trees")
    66                                           
    67                                               # filter the triple angles for good supports
    68         1  483782988.0 483782988.0      7.1      line_df["possible_anchor_triples"] = [generate_triple_angle(Point(line.coords[0]), line, anchor_trees) for line in line_df["line_candidates"]]
    69         1     680075.0 680075.0      0.0      line_df = line_df[line_df["possible_anchor_triples"].notnull()]
    70         1      55105.0  55105.0      0.0      print(len(line_df)," after possible anchor triples")
    71                                           
    72                                               # check if we have no height obstructions
    73         1        380.0    380.0      0.0      pos = []
    74         1 2253412802.0 2253412802.0     33.2      line_df["number_of_supports"], line_df["location_of_int_supports"] = zip(*[compute_required_supports(line, height_gdf, 0, plot_possible_lines, view, [], overall_trees, pos) for line in line_df["line_candidates"]])
    75                                               # and filter lines out without successful lines
    76         1     584760.0 584760.0      0.0      line_df = line_df[line_df["number_of_supports"].apply(lambda x: x is not False)]
    77         1      52672.0  52672.0      0.0      print(len(line_df)," after checking for height obstructions")
    78                                           
    79                                               # compute the angle between the line and the supports
    80         1   38098708.0 38098708.0      0.6      line_df["angle_between_supports"] = [compute_angle_between_supports(line, height_gdf) for line in line_df["line_candidates"]]
    81                                           
    82                                               # create a dict of the coords of the starting points        
    83         1      83047.0  83047.0      0.0      start_point_dict = dict([(key, value.coords[0]) for key, value in enumerate(line_df["line_candidates"])])
    84                                           
    85         1        291.0    291.0      0.0      if plot_possible_lines:
    86                                                   height_gdf_small = height_gdf.iloc[::10, :]
    87                                                   # pos of lines
    88                                                   pos_lines = np.hstack((pos)).T
    89                                                   # create scatter object and fill in the data
    90                                                   scatter = visuals.Markers()
    91                                                   scatter.set_data(pos_lines, edge_width=0, face_color=(1, 1, 0.5, 1), size=5)
    92                                                   view.add(scatter)
    93                                                   # possibility to connect lines, but doesnt really look good
    94                                                   # N,S = pos_lines.shape
    95                                                   # connect = np.empty((N*S-1,2), np.int32)
    96                                                   # connect[:, 0] = np.arange(N*S-1)
    97                                                   # connect[:, 1] = connect[:, 0] + 1
    98                                                   # for i in range(S, N*S, S):
    99                                                   #     connect[i-1, 1] = i-1 
   100                                                   # view.add(vispy.scene.Line(pos=pos_lines, connect=connect, width=5))
   101                                           
   102                                                   # pos of heightgdf
   103                                                   pos_height_gdf = np.vstack((height_gdf_small["x"], height_gdf_small["y"], height_gdf_small["elev"])).T
   104                                                   # create scatter object and fill in the data
   105                                                   scatter = visuals.Markers()
   106                                                   scatter.set_data(pos_height_gdf, edge_width=0, face_color=(1, 1, 1, .5), size=5)
   107                                                   view.add(scatter)
   108                                                   view.camera = 'turntable'  # or try 'arcball'
   109                                                   # add a colored 3D axis for orientation
   110                                                   axis = visuals.XYZAxis(parent=view.scene)
   111                                           
   112         1        124.0    124.0      0.0      return line_df, start_point_dict